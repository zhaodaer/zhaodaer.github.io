[{"title":"大顶堆和小顶堆","path":"/2024/04/29/大顶堆和小顶堆/","content":"因XXXXXX,故整理此文学习之，并留作备忘和参考 图解大顶堆的构建、排序过程 - 鹿呦呦 - 博客园 (cnblogs.com) 堆就是利用完全二叉树的结构来维护的一维数组 堆分为大顶堆和小顶堆 大顶堆：每个结点的值都大于或等于其左右孩子结点的值小顶堆：每个结点的值都小于或等于其左右孩子结点的值 如果是排序，求升序用大顶堆，求降序用小顶堆 一般我们说 topK 问题，就可以用大顶堆或小顶堆来实现， 最大的 K 个：小顶堆最小的 K 个：大顶堆 大顶堆的构建过程","tags":["知识卡片"],"categories":["知识卡片"]},{"title":"生产者-消费者模型","path":"/2024/04/27/生产者-消费者模型/","content":"因XXXXXX,故整理此文学习之，并留作备忘和参考 什么是生产者-消费者模式有两个进程A和B，共享一个固定大小的缓冲区，A进程是生产者，它将数据放入缓冲区，B进程是消费者，它从缓冲区中取出数据，这就是一个生产者和消费者的模式 如果缓冲区已经满了，生产者就不能继续生产； 如果缓冲区数据从无到有，生产者就得通知一下消费者，告诉它可以来消费了； 如果缓冲区已经没有产品了，消费者也无法继续消费； 如果缓冲区数据从满到不满，消费者也得去通知下生产者，说你可以来生产了。 ![[Pasted image 20240427214244.png]] 优点：解耦： 假设生产者和消费者分别是两个类。如果让生产者直接调用消费者的某个方法，那么生产者对于消费者就会产生依赖（也就是耦合）将来如果消费者的代码发生变化，可能会影响到生产者。而如果两者都依赖于某个缓冲区，两者之间不直接依赖，耦合也就相应降低了 支持并发： 生产者和消费者可以是两个独立的并发主体，生产者把制造出来的数据往缓冲区一丢，就可以再去生产下一个数据基本上不用依赖消费者的处理速度 平衡速度差异： 当生产者生产数据比较快的时候，会把消费者还没来得及处理的数据先放到缓冲区。等有空闲的消费者了，再去缓冲区拿去数据 用信号量实现用管程实现","tags":["知识卡片"],"categories":["知识卡片"]},{"title":"FreeRTOS笔记","path":"/2024/04/14/FreeRTOS知识点 复习笔记/","content":"本模块主要包括FreeRTOS的相关知识","tags":["学习笔记"],"categories":["学习笔记"]},{"title":"数据结构与算法笔记","path":"/2024/04/14/数据结构与算法 刷题笔记/","content":"1111 &#x3D;&#x3D;2024.03.24&#x3D;&#x3D; 数组数组是存放在连续内存空间上的相同类型数据的集合 通过 下标索引 的方式可以获取到下标所对应的数据 ![[Pasted image 20240324171048.png]] 数组在内存空间的地址是连续的，&#x3D;&#x3D;不能删除，只能覆盖&#x3D;&#x3D; 对于二维数组在C++中在地址空间上是连续的，但在JAVA中是不连续的。 &emsp; 1. 二分查找一种在有序数组中&#x3D;&#x3D;查找特定元素&#x3D;&#x3D;的算法 我是绿色 通过将待查找的值与数组中间元素进行比较，从而将待查找的范围缩小一半。如果待查找的值等于中间元素，则查找成功；如果待查找的值小于中间元素，则在左半部分继续查找；如果待查找的值大于中间元素，则在右半部分继续查找。通过不断缩小待查找范围，最终可以确定元素是否存在于数组中 当数组为有序数组，同时题目还强调数组中无重复元素时，可以想想是不是可以用二分查找&emsp; 二分法的&#x3D;&#x3D;两种&#x3D;&#x3D;写法左闭右闭 -&gt; Middle - 1 左开右开 -&gt; Middle 二分法的关键是对区间的定义理解清楚，在循环中根据查找区间的定义来做边界处理，也即循环不变量规则&emsp; &#x3D;&#x3D;力扣题&#x3D;&#x3D;&#x3D;&#x3D;34 在排序数组中查找元素的第一个和最后一个位置&#x3D;&#x3D;&#x3D;&#x3D;35 搜索插入位置&#x3D;&#x3D;123collapse: open给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。请必须使用时间复杂度为 O(log n) 的算法 ![[Pasted image 20240330150849.png]] 123456789101112131415161718192021222324class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0; int right = nums.size() - 1; while(left &lt;= right) &#123; int middle = left + (right - left)/2; if(nums[middle] &gt; target) &#123; right = middle - 1; &#125; else if(nums[middle] &lt; target) &#123; left = middle + 1; &#125; else return middle; &#125; // 四种情况： // 1. targrt最小，插入到数组第一个，应返回0. 此时left = right = 0，直接返回right即可 // 2. target为数组中的某个目标值，此时middle = target。 返回middle即可 // 3. 目标值并不存在，插入两个数之间，此时搜索的为[left，right]，则返回right + 1即可 // 4. target最大，插入数组末尾，返回right + 1即可 // 综上，返回right + 1 return right + 1; &#125;&#125;; &#x3D;&#x3D;704 二分查找&#x3D;&#x3D;12collapse: open给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1 左闭右闭写法：12345678910111213141516171819class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0; int right = nums.size() - 1; //定义target在左闭右闭的区间里 while(left &lt;= right)&#123; int middle = left + ((right - left) / 2); // 防止溢出 等同于(left + right)/2 if (nums[middle] &gt; target) &#123; right = middle - 1; &#125; else if (nums[middle] &lt; target) &#123; left = middle + 1; &#125; else &#123; return middle; &#125; &#125; return -1; &#125;&#125;; 左闭右开写法：12345678910111213141516171819class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0; int right = nums.size(); //定义target在左闭右开的区间里 while(left &lt; right)&#123; int middle = left + ((right - left) / 2); // 防止溢出 等同于(left + right)/2 if (nums[middle] &gt; target) &#123; right = middle; &#125; else if (nums[middle] &lt; target) &#123; left = middle; &#125; else &#123; return middle; &#125; &#125; return -1; &#125;&#125;; &emsp;&emsp; &#x3D;&#x3D;2024.03.25&#x3D;&#x3D; 2. 移除数组中的某个元素1234567collapse: open 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并**原地**修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 暴力法两层 for循环，第一层 for循环用于遍历寻找所需要删除的val，第二层 for循环用于后面的值覆盖前面所删除的值。 时间复杂度：O(n^2) 1234567891011121314151617class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; int size = nums.size(); for(int i= 0; i &lt; size; i++)&#123; if (nums[i] == val)&#123; for(int j = i + 1; j &lt; size; j++)&#123; nums[j - 1] = nums[j]; &#125; i--; size--; &#125; &#125; return size; &#125;&#125;; &emsp; 快慢指针法通过一个快指针和慢指针在一个for循环下完成两个for循环的工作 快指针用于寻找所需要删除的val，然后将快指针所寻找到的val的下一个元素赋值给慢指针。 一个 for循环就能解决，时间复杂度：O(n) 1234567891011121314class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; int slowIndex = 0; for(int fastIndex = 0; fastIndex &lt; nums.size(); fastIndex++)&#123; if (nums[fastIndex] != val)&#123; nums[slowIndex] = nums[fastIndex]; slowIndex++; &#125; &#125; return slowIndex; &#125;&#125;; &#x3D;&#x3D;2024.03.26&#x3D;&#x3D; 3. 有序数组的平方12collapse: open给你一个按非递减顺序排序的整数数组nums，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。 ![[977.有序数组的平方.gif]] 代码： 时间复杂度为O(n) 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) &#123; //定义一个大小为nums，元素都为0的数组reuslt vector&lt;int&gt; result(nums.size(), 0); //定义数组result的下标索引k int k = nums.size() - 1; for(int i = 0, j = nums.size() - 1; i &lt;= j; ) &#123; if(nums[i] * nums[i] &gt;= nums[j] * nums[j]) &#123; result[k] = nums[i] * nums[i]; k--; i++; &#125; else &#123; result[k] = nums[j] * nums[j]; k--; j--; &#125; &#125; return result; &#125;&#125;; &#x3D;&#x3D;2024.03.27&#x3D;&#x3D; 4. 长度最小的子数组力扣题209 12collapse: open给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0 采用滑动窗口（双指针）的方法：j 为终止位置，用于循环遍历数组的每个元素（第一层for循环）i 为起始位置，当 j 找到了和大于 s 的数组长度时，起始位置开始往后移，直到找到最小的长度 subLength （while循环） ![[209.长度最小的子数组.gif]] 1234567891011121314151617181920class Solution &#123;public: int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123; int result = INT32_MAX; int sum = 0; // 滑动窗口数值之和 int i = 0; // 滑动窗口起始位置 int subLength = 0; // 滑动窗口的长度 for (int j = 0; j &lt; nums.size(); j++) &#123; sum += nums[j]; // 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件 while (sum &gt;= s) &#123; subLength = (j - i + 1); // 取子序列的长度 result = result &lt; subLength ? result : subLength; sum -= nums[i++]; // 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置） &#125; &#125; // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列 return result == INT32_MAX ? 0 : result; &#125;&#125;; 5. 螺旋矩阵Ⅱ1234567891011collapse: open给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。示例:输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]1 2 38 9 47 6 5 ![[Pasted image 20240329214913.png]]1 2 3 412 13 14 511 16 15 610 9 8 7 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123; vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(n, 0)); // 使用vector定义一个二维数组 int startx = 0, starty = 0; // 定义每循环一个圈的起始位置 int loop = n / 2; // 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理 int mid = n / 2; // 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2) int count = 1; // 用来给矩阵中每一个空格赋值 int offset = 1; // 需要控制每一条边遍历的长度，每次循环右边界收缩一位 int i,j; //后置递减运算符，循环体&#123;&#125;会先执行，然后loop-- while (loop --) &#123; i = startx; j = starty; // 下面开始的四个for就是模拟转了一圈 // 模拟填充上行从左到右(左闭右开) for (j = starty; j &lt; n - offset; j++) &#123; res[startx][j] = count++; &#125; // 模拟填充右列从上到下(左闭右开) for (i = startx; i &lt; n - offset; i++) &#123; res[i][j] = count++; &#125; // 模拟填充下行从右到左(左闭右开) for (; j &gt; starty; j--) &#123; res[i][j] = count++; &#125; // 模拟填充左列从下到上(左闭右开) for (; i &gt; startx; i--) &#123; res[i][j] = count++; &#125; // 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1) startx++; starty++; // offset 控制每一圈里每一条边遍历的长度 offset += 1; &#125; // 如果n为奇数的话，需要单独给矩阵最中间的位置赋值 if (n % 2) &#123; res[mid][mid] = count; &#125; return res; &#125;&#125;; 链表哈希表（Hash table）也称散列表 当我们遇到了要快速判断一个元素是否出现集合里的时候，可以考虑哈希表但这是牺牲了空间换取了时间 key、value 与 哈希函数key值通过哈希函数映射到哈希表中 数组其实也是一张哈希表，数组下标索引为key值，通过下标可以直接访问数组中的元素 哈希碰撞拉链法、线性探测法 三种哈希表数组 数值、范围小用数组 set 数值、范围大用set map key对应value用map 力扣题242.有效的字母异位词12345collapse: open给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。示例 1: 输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot; 输出: true示例 2: 输入: s = &quot;rat&quot;, t = &quot;car&quot; 输出: false**说明:** 你可以假设字符串只包含小写字母。 &#96;&#96; ![[242.有效的字母异位词.gif]] 123456789101112131415161718192021class Solution &#123;public: bool isAnagram(string s, string t) &#123; int record[26] = &#123;0&#125;; for (int i = 0; i &lt; s.size(); i++) &#123; // 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了 record[s[i] - &#x27;a&#x27;]++; &#125; for (int i = 0; i &lt; t.size(); i++) &#123; record[t[i] - &#x27;a&#x27;]--; &#125; for (int i = 0; i &lt; 26; i++) &#123; if (record[i] != 0) &#123; // record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。 return false; &#125; &#125; // record数组所有元素都为零0，说明字符串s和t是字母异位词 return true; &#125;&#125;; 349. 两个数组的交集12collapse: open给定两个数组，编写一个函数来计算它们的交集。 ![[Pasted image 20240401204409.png]] 用set来实现12345678910111213141516171819202122class Solution &#123;public: vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; //存放结果的result_set unordered_set&lt;int&gt; result_set; //将nums1初始化成nums_set unordered_set&lt;int&gt; nums_set(nums1.begin(), nums1.end()); //循环遍历nums2中每一个元素（num） for(int num : nums2) &#123; //如果nums2中的值存在于nums1中，则插入result_set中 if(nums_set.find(num) != nums_set.end()) &#123; result_set.insert(num); &#125; &#125; //最后将reesult_set转化为vector return vector&lt;int&gt;(result_set.begin(), result_set.end()); &#125;&#125;; 用数组来实现1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int hash[1005] = &#123;0&#125;; unordered_set&lt;int&gt; result_set; for(int num : nums1) &#123; //将对应的 hash 数组中的元素标记为 1，表示该元素存在于 nums1 中 hash[num] = 1; &#125; //遍历 nums2 中的每个元素 num。 //如果 num 在 hash 数组中的对应位置为 1，则将其插入到结果集 result_set 中 for(int num : nums2) &#123; if(hash[num] == 1) &#123; result_set.insert(num); &#125; &#125; return vector&lt;int&gt;(result_set.begin(), result_set.end()); &#125;&#125;; 202. 快乐数1234567collapse: open编写一个算法来判断一个数 `n` 是不是快乐数。**「快乐数」** 定义为：- 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。- 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。- 如果这个过程 **结果为** 1，那么这个数就是快乐数。如果 `n` 是 _快乐数_ 就返回 `true` ；不是，则返回 `false` 。 ![[Pasted image 20240402200102.png]] 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: int getSum(int n) &#123; int sum = 0; while(n) &#123; sum += (n % 10) * (n % 10); n /= 10; &#125; return sum; &#125; bool isHappy(int n) &#123; unordered_set&lt;int&gt; set; while(1) &#123; int sum = getSum(n); //如果sum为1，则为快乐数，直接返回 if(sum == 1) &#123; return true; &#125; //如果sum在set中出现过了，则为出现了循环 if(set.find(sum) != set.end()) &#123; return false; &#125; //否则，将sum再次插入set中 else &#123; set.insert(sum); &#125; //进行多次迭代 n = sum; &#125; &#125;&#125;; 1. 两数之和123456789collapse: open给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。**示例:**给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 本题思路： 首先需要一个集合（map）来存放我们遍历过的元素，然后在遍历数组的时候去询问这个集合，某元素是否遍历过，也就是 是否出现在这个集合。 例如上题，在遍历第一个元素 2 时，需要元素 7，于是去询问map中是否出现过7，此时map为空，于是将 2 的值（key）和下标（value）存进map中。然后遍历第二个元素，发现是 7，于是再去寻找map中是否有 7，发现有 7，于是返回二者下标。 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; //创建一个map，用于存储遍历过的元素 unordered_map&lt;int, int&gt; map; for(int i = 0; i &lt; nums.size(); i++) &#123; //在map中查找是否有匹配的key，并将返回的迭代器赋值给 iter auto iter = map.find(target - nums[i]); //如果在map中找到了遍历过的key，则返回二者下标 if(iter != map.end()) &#123; return &#123;iter-&gt;second, i&#125;; &#125; //否则，插入map中 map.insert(pair&lt;int,int&gt;(nums[i], i)); &#125; //若最后没有符合的元素，则返回空下标 return &#123;&#125;; &#125;&#125;; 454. 四数相加1234collapse: open给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。 ![[Pasted image 20240403210409.png]] 123456789101112131415161718192021222324252627class Solution &#123;public: int fourSumCount(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, vector&lt;int&gt;&amp; nums3, vector&lt;int&gt;&amp; nums4) &#123; //定义了umap，其中key为a+b的值，value为a+b出现的次数 unordered_map&lt;int, int&gt; umap; //循环遍历nums1、nums2中的每一个元素，将两个数组中的任意元素两两相加 //将两个元素相加的和作为key存入umap中，当出现相同的key时，将其次数（value作为次数）相加 for(int a : nums1)&#123; for(int b : nums2)&#123; umap[a + b]++; &#125; &#125; int count = 0; for(int c : nums3)&#123; for(int d : nums4)&#123; if(umap.find(0 -(c + d)) != umap.end())&#123; count += umap[0 - (c + d)]; &#125; &#125; &#125; return count; &#125;&#125;; 15. 三数之和123456collapse: open给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 `0` 且不重复的三元组。**注意：**答案中不可以包含重复的三元组。 本题思路： 用双指针法，先对数组进行排序。定义三个指针，其中i 用作遍历数组中的每一个元素，left 和right 用于移动来寻找nums[i] + nums[left] + nums[right] &#x3D; 0 的元素 我们先去判断nums[i] + nums[left] + nums[right] 是否为0，若&gt;0 ，将left右移；同理&lt;0，right左移；若&#x3D;0，则返回result 注意要进行去重的操作！！！ ![[15.三数之和.gif]] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; result; //将数组进行排序 sort(nums.begin(), nums.end()); //遍历 for(int i = 0; i &lt; nums.size(); i++) &#123; //如果第一个数大于0，则后面的数一定大于0，不可能出现三数之和等于0，直接返回 if(nums[i] &gt; 0) &#123; return result; &#125; //a的去重：a与a的前一个若相同，则跳过本次循环，立即进行下一次的循环条件判定 if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; //定义b， c int left = i + 1; int right = nums.size() - 1; //判断三数之和是否等于0 while(left &lt; right) &#123; if(nums[i] + nums[left] + nums[right] &lt; 0)&#123; left++; &#125; else if(nums[i] + nums[left] + nums[right] &gt; 0)&#123; right--; &#125; else &#123; result.push_back(vector&lt;int&gt;&#123;nums[i] , nums[left] , nums[right]&#125;); //b, c去重 while(right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right--; while(right &gt; left &amp;&amp; nums[left] == nums[left - 1]) left--; //找到答案后，双指针同时收缩 left++; right--; &#125; &#125; &#125; return result; &#125;&#125;; 18. 四数之和2024.04.14 字符串反转字符串1234collapse: open编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 `s` 的形式给出。不要给另外的数组分配额外的空间，你必须**[原地](https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)修改输入数组**、使用 O(1) 的额外空间解决这一问题。 利用双指针法，以及swap() 库函数![[344.反转字符串.gif]] 反转字符串Ⅱ12345collapse: open给定一个字符串 `s` 和一个整数 `k`，从字符串开头算起，每计数至 `2k` 个字符，就反转这 `2k` 字符中的前 `k` 个字符。- 如果剩余字符少于 `k` 个，则将剩余字符全部反转。- 如果剩余字符小于 `2k` 但大于或等于 `k` 个，则反转前 `k` 个字符，其余字符保持原样。 同样利用双指针法 在for循环中 i 直接移动2k 个字符 1for(int i = 0; i &lt; s.size(); i += 2 * k)","tags":["学习笔记"],"categories":["学习笔记"]},{"title":"计算机网络笔记","path":"/2024/04/14/计算机网络、组成原理相关知识笔记/","content":"1111 计算机网络体系结构![[Pasted image 20240406195146.png]] ![[Pasted image 20240406200010.png]] ![[Pasted image 20240406200533.png]] ![[Pasted image 20240406201312.png]] 物理层物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流 物理层为数据链路层屏蔽了各种传输媒体的差异，使数据链路层只需要考虑如何完成本层的协议和服务，而不必考虑网络具体的传输媒体是什么","tags":["学习笔记"],"categories":["学习笔记"]},{"title":"QT笔记","path":"/2024/04/14/QT开发 学习笔记/","content":"444","tags":["学习笔记"],"categories":["学习笔记"]},{"title":"Linux笔记","path":"/2024/04/14/Linux系统C C++编程知识点 复习笔记/","content":"本模块主要包含Linux系统编程的相关操作，以及C&#x2F;C++的相关知识点总结 1. 📉基础绝对路径： 是一个完整的路径，它从根目录（root）开始，一直到目标目录。例如，/home/user/Documents 是一个绝对路径，指向了文件系统中的 /（根目录）下的 home 目录，然后是 user 目录，最后是 Documents 目录。 相对路径： 相对于当前工作目录的路径。不提供完整的路径，而是描述了如何从当前目录导航到目标目录。例如，假设当前工作目录是 /home/user，要进入 Documents 目录，可以使用相对路径 Documents。 基础命令Linux 命令大全 | 菜鸟教程 (runoob.com) 命令 用法 说明 意义 pwd 显示当前目录 cd cd .. 上一级目录 cd ~ 进入家目录 cd - 切回上一次操作的目录 cd &#x2F; 进入根目录 cp cp a b 将a复制一份命名为b ls ls -l 查看文件的属性权限 mkdir 创建目录 rmdir 删除目录 （只能删除空目录） rm rm -rf &lt;目录路径&gt; echo echo abc &gt; 1.1.txt 创建一个文件 cat 列出文件的内容 touch a touch a 摸一下该文件，只改时间，不改内容 mv mv a ..&#x2F; 将a移动到上一级目录里 mv ..&#x2F;a . 将上一级目录里的a移动到当前目录 tab键 tab键 补全当前目录下的文件名 chmod chmod 675 &lt;某个文件&gt; 改变文件的权限（拥有者、同组其他用户和其他用户的可读r、可写w、可执行r等） chmod -x &lt;某个文件&gt; 权限全部去掉 chowm chown root root &lt;某个文件&gt; 改变文件的拥有者、其他用户等 改变文件的所有者 root 用户切换、登录、设置密码（不建议用 sudo 临时切换为root用户 这个命令nb find find abc -name *.1.txt 指定当前目录下的abc文件夹下查找名字为1.1.txt、2.1.txt等文件 grep grep “xyz” * -nwr 递归查找当前目录下的所以文件中含有xyz字符的文件 tar tar czf abc def 创建压缩包 用gzip命令压缩 将def文件压缩为名为abc的压缩包（也可以压缩目录） 压缩 tar xzf abc -C aaa 将压缩包abc解压到aaa目录里去 用gzip解压 解压 man echo echo 122 &gt; 1.txt 将1.txt中的内容替换为122 覆盖型写法 (原来内容被覆盖) echo abc &gt;&gt; 1.txt 输出为 122 abc 添加型写法 (新内容添加在原来内容的后面） 快捷键 Ctrl + C：中断当前正在运行的命令。 Ctrl + Z：将当前正在运行的命令放入后台。 Ctrl + P：重复上一条指令。 Ctrl + D：在命令行中输入EOF（End of File）。 Ctrl + L：清屏，相当于执行”clear”命令。 Ctrl + A：将光标移动到命令行的开头。 Ctrl + E：将光标移动到命令行的末尾。 Ctrl + K：删除光标位置到行末的内容。 Ctrl + U：删除光标位置到行首的内容。 Ctrl + W：删除光标前的一个单词。 Ctrl + R：在历史命令中进行反向搜索。 Ctrl + G：退出历史命令搜索模式。 Tab键：自动补全命令或文件名。 文件&#x2F;目录的权限在 ls -l 命令的输出中，drwxrwxr-x 是文件或目录的权限字符串 第一个字符表示文件类型： - 表示普通文件。 d 表示目录。 l 表示符号链接（link）。 c 表示字符设备文件。 b 表示块设备文件。 s 表示套接字（socket）。 p 表示管道（pipe）。 后面的九个字符分为三组，每组三个字符代表一个用户权限集（&#x3D;&#x3D;所有者、群组、其他用户&#x3D;&#x3D;）： 第一组代表文件所有者的权限。 第二组代表与文件所有者同一群组的用户的权限。 第三组代表其他用户的权限。 VIM 文本编辑器命令模式 编辑模式 小技巧测试NAT网卡能不能用： 利用ping www.baidu.com 测试 不行的话 打开服务，把关于VMware的所有服务都启动 2. gcc编译器编译过程![[Pasted image 20240331180912.png]] 1gcc test.c -o test 命令执行后将会把 test.c 文件变成可执行文件 text（其中的预处理、编译、汇编、链接过程可一并解决） 3.📉Shell脚本Shell脚本通常使用Bash或其他类Unix系统上的Shell解释器执行，约为Windows下的批处理 示例： 假设我们有一个名为backup.sh的Shell脚本，用于备份指定目录中的文件到另一个目录。脚本会将文件压缩并复制到备份目录中。 1234567891011#!/bin/bash # 源目录和备份目录 source_dir=&quot;/path/to/source&quot; backup_dir=&quot;/path/to/backup&quot; # 创建备份目录（如果不存在） mkdir -p &quot;$backup_dir&quot; # 备份文件 tar -czf &quot;$backup_dir/backup_$(date +&#x27;%Y%m%d&#x27;).tar.gz&quot; &quot;$source_dir&quot; 4.📉Makefile区别： Shell脚本：主要用于执行&#x3D;&#x3D;一系列命令&#x3D;&#x3D;或操作系统功能，以实现特定的任务 Makefile：主要用于&#x3D;&#x3D;管理项目&#x3D;&#x3D;的构建过程，包括编译源代码、链接目标文件、生成可执行文件等。Makefile描述了源文件之间的依赖关系，以及如何生成目标文件","tags":["学习笔记"],"categories":["学习笔记"]},{"title":"内核笔记","path":"/2024/04/14/Linux内核 学习笔记/","content":"333","tags":["学习笔记"],"categories":["学习笔记"]},{"title":"操作系统笔记","path":"/2024/04/14/操作系统笔记/","content":"本文记录了有关操作系统的知识笔记，包括内存管理、进程线程管理等 ![[73d6dae5351a4e73a2aad2da02e66fdb 1.gif]] 操作系统是管理硬件资源的 CPU的调度，进程与线程 内存：物理内存、虚拟内存 磁盘，文件系统 中断，I/O设备 并发与并行 并发（Concurrency）： 并发指的是系统中能够同时处理多个任务的能力。这些任务可以在时间上重叠，但实际上在任意给定的时间点只有一个任务在被执行。即==多个任务之间交替进行==，但不一定是同时在执行。 并行（Parallelism）： 并行是指系统中同时执行多个任务的能力，多个任务在同一时刻同时运行。这可以通过多处理器、多核心处理器或者分布式系统等方式实现。 并行更多地强调的是物理上的同时性，即==多个任务真正同时在执行==。 操作系统==特征== 并发性（Concurrency）：操作系统能够同时管理多个任务，实现多任务的并发执行 共享性（Sharing）：操作系统能够有效地管理计算机系统的各种资源，包括处理器、内存、存储器、设备等，以实现资源的共享和高效利用，从而满足多个用户或多个程序同时访问和使用系统资源的需求。 虚拟性（Virtualization）：操作系统能够通过虚拟化技术将物理资源抽象为逻辑资源，例如，CPU虚拟化为进程、内存虚拟化成地址空间、磁盘虚拟化成文件，从而为用户和应用程序提供更高层次的抽象和更方便的访问接口。 异步性（Asynchrony）：操作系统中的各个组件和任务之间的执行是异步的，它们可能以不同的速度执行，相互之间的执行顺序和时序不确定，操作系统需要能够有效地管理和调度这种异步执行的过程。 操作系统 启动！DISK : 存放OS和bootloader BIOS : 基本 I/O 处理系统 bootloader 在硬盘的第一个扇区，仅512个字节 首先操作系统的代码是存在硬盘DISK中的，当电脑启动后，BIOS会将bootloader 从硬盘DISK放到内存中去，，，这时BIOS加载bootloader，再加载OS，将CPU的控制权交给OS 操作系统是如何与==外设==和==应用程序==打交道的？ 通过==中断和I/O==与外设打交道通过==系统调用和异常==与应用程序打交道 中断(来源于外设)，来自不同的硬件设备的计时器和网络的中断 系统调用(来源于应用程序)，是由应用程序主动向操作系统发出服务请求（一条特殊的指令） 异常(来源于不良的应用程序)，非法指令或者其他坏的处理状态(如:内存出错) 中断的执行过程： 当外设需要操作系统产生相应的服务时，会产生一个中断标记，此时CPU会产生一个特定的中断号ID，然后将中断号ID发给操作系统 当操作系统发现中断产生后，首先会保存当前现场，然后根据中断号处理相应中断，执行完成后清楚中断标记，最后恢复现场 异常的执行过程： 与中断类似，都会产生一个（异常）编号，然后操作系统保存现场，再执行异常处理（1. 杀死产生了异常的程序 2. 重新执行异常指令），最后恢复现场 操作系统是如何实现系统调用的？ 当应用程序调用一个系统调用时，会完成从用户态到内核态的转换，控制权从CPU交到了操作系统手中 ![[Pasted image 20240401215059.png]] 操作系统如何管理物理内存地址空间物理地址空间，硬件支持的地址空间 逻辑地址空间，一个运行的程序所拥有的内存范围，最终还是映射到物理地址空间 逻辑地址空间的生成过程逻辑地址到物理地址的映射关系连续内存分配分区的动态分配首次适配：第一个 最优适配：最接近 最差适配：最大包最小 但都会产生碎片（碎片化问题）-&gt;内碎片、外碎片 内碎片：分配给了程序，但未被实际使用的碎片外碎片：未分配给程序的碎片 碎片整理压缩式碎片整理：将多个内存空间拷贝移动，腾出更多的内存空间，使得空间可以连续 交换式碎片整理：将某些没有正在运行的程序由内存移入硬盘 非连续内存分配分段： 段号 + 段内偏移，能够更好的分离和共享 分页： 页内偏移的大小是固定的 页表是一种数据结构，用于存储虚拟地址空间与物理地址空间之间的映射关系 虚拟内存虚拟内存 可以让程序可以拥有超过系统物理内存大小的可用内存空间。同时让应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），实际的物理内存是不连续的 重要意义：定义了一个连续的虚拟地址空间，并且 把内存扩展到硬盘空间。程序一小部分在内存上，大部分在硬盘中。也即把硬盘当成了一个虚拟空间 过程：当进程开始运行时，先将一部分程序装入内存，另一部分暂时留在外存；调入内存正在运行的程序，是以页为单位调入内存中。就是因为是一小部分，所以执行时肯定会遇到不在页中的情况，这时候就会请求调页当要执行的指令不在内存时，由系统自动完成将它们调入内存的工作；当没有足够的内存时，系统自动选择部分内存（暂不执行的程序）空间，将其中原有的内容交换到磁盘上，并释放这些内存空间供其他进程使用。 虚拟寻址(Virtual Addressing) ：使用虚拟寻址，CPU通过内存管理单元存放在内存中的页表来动态地将虚拟地址翻译成物理地址，以此来访问到真实的物理内存。 缺页中断的异常处理 ![[Pasted image 20240408203738.png]] ![[Pasted image 20240408204634.png]] 虚拟内存管理算法十年大佬讲述，操作系统内存管理(图文详解) - 知乎 (zhihu.com) 进程管理进程是程序功能的体现 进程是动态的，程序是静态的 程序是有序代码的集合;进程是程序的执行，进程有核心态/用户态 两个进程之间是相互独立的，进程a不能访问进程b的地址空间 ![[Pasted image 20240411212850.png]] 程序 = 算法 十 数据结构 描述进程的数据结构：进程控制块(Process Control Block， PCB ) 操作系统为每个进程都维护了一个PCB，用来保存与该进程有关的各种状态信息。 进程控制块进程的状态进程创建进程就绪进程运行进程阻塞进程结束 进程挂起模型线程管理一个进程中可以同时存在多个线程 多个线程之间可以并发地执行，并可以共享相同的地址空间 ！！！ 当一个线程崩溃，会导致其所属进程的所有线程崩溃 进程有两部分组成，一部分是资源管理，一部分是线程 进程是资源分配单位，线程是CPU调度单位 线程的创建时间和终止时间比进程短 在同一个进程内的线程切换时间比进程短，因为同一进程内的各个线程是共享内存和文件资源的，可直接进行通信，而不需要通过内核 单线程和多线程![[Pasted image 20240414132703.png]] 用户线程和内核线程用户线程是指在用户空间实现的线程机制，不依赖于操作系统内核 由一组用户级的线程库函数来完成线程的创建、终止、同步和调度等 每个线程都拥有自己私有的TCB，因用户线程的切换是由线程库函数来完成，无需用户态到和心态的切换，所以速度特别快 内核线程是指在操作系统内核中实现的一种线程机制，由操作系统内核来完成线程的创建、终止和管理 此时内核同时维护进程和线程的PCB和TCB 因为线程的创建、终止和切换都是由内核来完成，所以系统开销比较大 进程的上下文切换停止当前进程（从运行态改变到其他状态）并且调度其他进程（转变成运行状态） 上下文切换是非常频繁的，它的速度是非常快的 在切换上下文是要保存现场 进程的创建、加载、执行、等待、终止fork() 函数123456789101112131415161718192021222324#include &lt;unistd.h&gt;#include &lt;stdio.h&gt; int main () &#123; pid_t fpid; //fpid表示fork函数返回的值\tint count=0;\tfpid=fork(); if (fpid &lt; 0) printf(&quot;error in fork!&quot;); else if (fpid == 0) &#123; printf(&quot;i am the child process, my process id is %d/n&quot;,getpid()); printf(&quot;我是爹的儿子/n&quot;);//对某些人来说中文看着更直白。 count++;\t&#125;\telse &#123; printf(&quot;i am the parent process, my process id is %d/n&quot;,getpid()); printf(&quot;我是孩子他爹/n&quot;); count++;\t&#125;\tprintf(&quot;统计结果是: %d/n&quot;,count);\treturn 0;&#125; 在fork函数执行完后，如果创建新进程成功，则出现两个进程，一个是子进程，一个是父进程 在子进程中，fork函数返回0在父进程中，fork返回新创建子进程的进程ID 我们可以通过fork返回的值来判断当前进程是子进程还是父进程 exec() 函数在一个进程内部来启动另一个程序的执行 exec把当前进程映像替换成新的程序文件，而且该新程序通常从main函数开始执行。进程ID并不改变。我们称调用exec的进程为调用进程(calling process)，称新执行的程序为新程序 exit() 退出函数wait() 函数子进程执行exit() 函数后会结束，然后返回给父进程一个值，然后父进程必须接受这个值并执行，所以会执行wait() 函数释放掉一系列资源 在exit() 函数执行后，而wait() 函数执行前，会处于僵尸态 ![[Pasted image 20240414150902.png]]","tags":["学习笔记"],"categories":["学习笔记"]},{"path":"/about/index.html","content":"写在前面11111欢迎来到我的笔记小站！ 终生学习的重要性不言而喻，培根说过：To live is to learn, to learn is not to live。意思是【活着就要学习，学习不是为了活着】。 所以在有生之年，我将把我想学的知识系统地记录在这里，也希望能对你有帮助。"},{"title":"站","path":"/notes/站点美化/index.html","content":"新的起点测试一下这里写会发生什么，我需要掌握什么。 了解计算机图形学学习计算机图形学大纲。新的起点测试一下这里写会发生什么，我需要掌握什么。 了解计算机图形学学习计算机图形学大纲。"},{"title":"Gamer","path":"/notes/Gamer/index.html","content":"新的起点"},{"title":"碎碎念","path":"/wiki/碎碎念/111.html","content":"啊啊啊啊啊啊啊啊哇哇哇哇哇哇哇哇"}]